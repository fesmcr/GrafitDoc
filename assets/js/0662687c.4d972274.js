"use strict";(self.webpackChunkgrafit_doc=self.webpackChunkgrafit_doc||[]).push([[6753],{1241:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>i,metadata:()=>h,toc:()=>o});var r=t(4848),s=t(8453);t(1470),t(9365);const i={},d="AGraph",h={id:"doc-sharp/AGraph",title:"AGraph",description:"AGraph",source:"@site/docs/doc-sharp/AGraph.md",sourceDirName:"doc-sharp",slug:"/doc-sharp/AGraph",permalink:"/GrafitDoc/docs/doc-sharp/AGraph",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"API Documentation",permalink:"/GrafitDoc/docs/category/api-documentation"},next:{title:"CMeasure",permalink:"/GrafitDoc/docs/doc-sharp/CMeasure"}},a={},o=[{value:"AGraph",id:"agraph-1",level:2},{value:"Nodes",id:"nodes",level:2},{value:"NoValue",id:"novalue",level:2},{value:"UndirectedEdges",id:"undirectededges",level:2},{value:"NextMatrix",id:"nextmatrix",level:2},{value:"AdjacencyMatrix",id:"adjacencymatrix",level:2},{value:"NodesCount",id:"nodescount",level:2},{value:"WeightMatricesCount",id:"weightmatricescount",level:2},{value:"DirectedEdgesCount",id:"directededgescount",level:2},{value:"UndirectedEdgesCount",id:"undirectededgescount",level:2},{value:"GetShortestPathDistance",id:"getshortestpathdistance",level:2},{value:"GetShortestPathNodeIds",id:"getshortestpathnodeids",level:2},{value:"GetShortestPathNodeAndEdgeIds",id:"getshortestpathnodeandedgeids",level:2},{value:"GetShortestPathNodeAndEdgeIds",id:"getshortestpathnodeandedgeids-1",level:2},{value:"GetAngleBetweenEdgesByNodesIds",id:"getanglebetweenedgesbynodesids",level:2},{value:"GetUndirectedEdgesAsNodeIdsFlatArray",id:"getundirectededgesasnodeidsflatarray",level:2},{value:"JoinForwardAndBackwardWeightsAsFlatArray",id:"joinforwardandbackwardweightsasflatarray",level:2},{value:"GetWeightMatrixById",id:"getweightmatrixbyid",level:2},{value:"IsAdjacent",id:"isadjacent",level:2},{value:"IsNodeIdValid",id:"isnodeidvalid",level:2},{value:"GetUndirectedEdgeId",id:"getundirectededgeid",level:2},{value:"GetDirectedAndUndirectedEdgeIdByNodes",id:"getdirectedandundirectededgeidbynodes",level:2},{value:"GetUndirectedEdgeIdByNodes",id:"getundirectededgeidbynodes",level:2},{value:"GetDirectedEdgeIdByNodes",id:"getdirectededgeidbynodes",level:2},{value:"GetOppositeEdgeId",id:"getoppositeedgeid",level:2},{value:"GetNodeIdsByEdgeId",id:"getnodeidsbyedgeid",level:2},{value:"GetSubgraphs",id:"getsubgraphs",level:2},{value:"APShortestPathsByOneWeight",id:"apshortestpathsbyoneweight",level:2},{value:"APShortestPathsByManyWeights",id:"apshortestpathsbymanyweights",level:2},{value:"InitializeNextMatrix",id:"initializenextmatrix",level:2},{value:"AddEmptyWeightMatrix",id:"addemptyweightmatrix",level:2},{value:"AddWeightMatrix",id:"addweightmatrix",level:2},{value:"RemoveWeightMatrix",id:"removeweightmatrix",level:2},{value:"SetWeightMatrixValue",id:"setweightmatrixvalue",level:2},{value:"SetWeightMatrixAndEdgeValue",id:"setweightmatrixandedgevalue",level:2},{value:"GetEdgeValue",id:"getedgevalue",level:2},{value:"GetEdgeValue",id:"getedgevalue-1",level:2},{value:"GetWeightMatrixValue",id:"getweightmatrixvalue",level:2},{value:"FillWeightMatrixBySPRestore",id:"fillweightmatrixbysprestore",level:2},{value:"ConvertDoubleToFloatJaggedArray",id:"convertdoubletofloatjaggedarray",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"agraph",children:"AGraph"}),"\n",(0,r.jsx)(n.h2,{id:"agraph-1",children:"AGraph"}),"\n",(0,r.jsx)(n.p,{children:"Represents an abstract base class for a graph data structure."}),"\n",(0,r.jsx)(n.h2,{id:"nodes",children:"Nodes"}),"\n",(0,r.jsx)(n.p,{children:"Gets the list of nodes in the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsxs)(n.p,{children:["The list of ",(0,r.jsx)(n.a,{href:"#"})," objects representing the nodes within the graph."]}),"\n",(0,r.jsx)(n.h2,{id:"novalue",children:"NoValue"}),"\n",(0,r.jsx)(n.p,{children:"Gets the value used to represent an absence of value or an invalid state."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"An integer indicating the absence of a valid value. By default set to -1."}),"\n",(0,r.jsx)(n.h2,{id:"undirectededges",children:"UndirectedEdges"}),"\n",(0,r.jsx)(n.p,{children:"Gets the collection of undirected edges in the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"A list of integer arrays, where each array contains two elements representing the node IDs."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:'\r\nvar undirectedEdges = graph.UndirectedEdges;\nforeach (var edge in undirectedEdges)\n{\n    Console.WriteLine($"Edge between node ID {edge[0]} and node ID {edge[1]}");\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"nextmatrix",children:"NextMatrix"}),"\n",(0,r.jsx)(n.p,{children:"Gets the 'Successor' matrix used to reconstruct the paths between nodes in the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"A two-dimensional array of integers where each element [i][j] represents the next node\r\non the shortest path from node i to node j."}),"\n",(0,r.jsx)(n.h2,{id:"adjacencymatrix",children:"AdjacencyMatrix"}),"\n",(0,r.jsx)(n.p,{children:"Gets the adjacency matrix representing the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"A two-dimensional array where each element [i][j] represents the presence (Edge Id) or absence (int.MaxValue) of an edge between node i and node j."}),"\n",(0,r.jsx)(n.h2,{id:"nodescount",children:"NodesCount"}),"\n",(0,r.jsx)(n.p,{children:"Gets the total number of nodes in the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"The count of nodes currently present in the graph."}),"\n",(0,r.jsx)(n.h2,{id:"weightmatricescount",children:"WeightMatricesCount"}),"\n",(0,r.jsx)(n.p,{children:"Gets the total number of weight matrices in the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"The count of weight matrices that have been added to the graph."}),"\n",(0,r.jsx)(n.h2,{id:"directededgescount",children:"DirectedEdgesCount"}),"\n",(0,r.jsx)(n.p,{children:"Gets the total count of directed edges in the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"The count of directed edges, which is twice the number of undirected edges since each undirected edge is represented by two directed edges in opposite directions."}),"\n",(0,r.jsx)(n.h2,{id:"undirectededgescount",children:"UndirectedEdgesCount"}),"\n",(0,r.jsx)(n.p,{children:"Gets the total count of undirected edges in the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Value"})}),"\n",(0,r.jsx)(n.p,{children:"The number of undirected edges."}),"\n",(0,r.jsx)(n.h2,{id:"getshortestpathdistance",children:"GetShortestPathDistance"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the shortest path distance between two nodes using a specified weight matrix."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"FromNodeId"})," - The ID of the starting node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"ToNodeId"})," - The ID of the destination node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier for the weight matrix to be used for lookup."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method directly accesses the specified weight matrix to retrieve the distance between the 'From' and 'To' nodes.\r\nIf the 'From' and 'To' nodes are the same, it returns a default distance value defined by ",(0,r.jsx)(n.a,{href:"agraph#tzero",children:"TZero"}),",\r\nwhich represents the absence of distance or a path of length zero."]}),"\n",(0,r.jsxs)(n.p,{children:["Ensure that the nodes and weight matrix ID are valid before calling this method to avoid out-of-range errors.\r\nThis method assumes that the shortest path distances have been computed and stored in the weight matrices.\r\nSee ",(0,r.jsx)(n.a,{href:"agraph#apshortestpathsbyoneweight",children:"APShortestPathsByOneWeight"})," and ",(0,r.jsx)(n.a,{href:"agraph#apshortestpathsbymanyweights",children:"APShortestPathsByManyWeights"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The shortest path distance of type  (double or float) between the 'From' and 'To' nodes.\r\nReturns 0 if the 'From' and 'To' nodes are the same."}),"\n",(0,r.jsx)(n.h2,{id:"getshortestpathnodeids",children:"GetShortestPathNodeIds"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the shortest path as a list of node IDs between two specified node Ids."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"From"})," - The ID of the starting node (always a Primal one)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"To"})," - The ID of the destination node (always a Primal one)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method returns the list of node IDs that form the shortest path from a starting node to a destination node.\r\nEnsure that node IDs correspond to the primal graph (points), not to the dual graph nodes (lines).\r\nThis method assumes that the shortest path distances have been computed and stored.\r\nSee ",(0,r.jsx)(n.a,{href:"agraph#apshortestpathsbyoneweight",children:"APShortestPathsByOneWeight"})," and ",(0,r.jsx)(n.a,{href:"agraph#apshortestpathsbymanyweights",children:"APShortestPathsByManyWeights"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"If the starting and ending nodes are the same, the method returns a list containing only the\r\nstarting node ID."}),"\n",(0,r.jsx)(n.p,{children:"If a path cannot be found due to a broken path or if any intermediate node leads to a cycle\r\nthe method returns null."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A list of node IDs representing the shortest path from the starting node to the\r\ndestination node, or null if no valid path exists."}),"\n",(0,r.jsx)(n.h2,{id:"getshortestpathnodeandedgeids",children:"GetShortestPathNodeAndEdgeIds"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the shortest path between two nodes as both node and edge IDs, considering the graph's directionality."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"FromNodeId"})," - The ID of the starting node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"ToNodeId"})," - The ID of the destination node."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method first determines the shortest path by node IDs from the starting node to the destination node using ",(0,r.jsx)(n.a,{href:"agraph#getshortestpathnodeids",children:"GetShortestPathNodeIds"}),". It then translates this path into edge IDs, which represent the connections between consecutive nodes in the path. The method return edges result as directed or undirected edge ids, using the appropriate function (",(0,r.jsx)(n.a,{href:"agraph#getdirectededgeidbynodes",children:"GetDirectedEdgeIdByNodes"})," or ",(0,r.jsx)(n.a,{href:"agraph#getundirectededgeidbynodes",children:"GetUndirectedEdgeIdByNodes"}),") to find edge IDs based on node pairs.\r\nEnsure that node IDs correspond to the primal graph (points), not to the dual graph nodes (lines).\r\nIf the starting and ending nodes are the same, the method returns a node list containing only the\r\nstarting node ID and empty edge list."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A tuple containing two lists: the first list contains the node IDs in the shortest path,\r\nand the second list contains the corresponding edge IDs."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:"\r\nvar (nodeIds, edgeIds) = graph.GetShortestPathNodeAndEdgeIds(fromNodeId, toNodeId, isDirected);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"getshortestpathnodeandedgeids-1",children:"GetShortestPathNodeAndEdgeIds"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the shortest path between two nodes as both node and edge IDs, considering the graph's directionality."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"FromNodeId"})," - The ID of the starting node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"ToNodeId"})," - The ID of the destination node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"NodePathIds"})," - An output parameter to hold the list of node IDs comprising the shortest path."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"EdgePathIds"})," - An output parameter to hold the list of edge IDs comprising the shortest path."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method is the same as ",(0,r.jsx)(n.a,{href:"agraph#getshortestpathnodeandedgeids",children:"GetShortestPathNodeAndEdgeIds"})," but result returned via out parameters."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:"\r\ngraph.GetShortestPathNodeAndEdgeIds(fromNodeId, toNodeId, isDirected, out List<int> nodePath, out List<int> edgePath);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"getanglebetweenedgesbynodesids",children:"GetAngleBetweenEdgesByNodesIds"}),"\n",(0,r.jsx)(n.p,{children:"Calculates the angle between two edges defined by three node IDs."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"NodeId1"})," - The ID of the first node, forming the start of the first edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"NodeId2"})," - The ID of the second node, shared by both edges."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"NodeId3"})," - The ID of the third node, forming the end of the second edge."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method calculates the angle between two edges that share a common node. The edges are defined by the nodes\r\n(NodeId1, NodeId2) and (NodeId2, NodeId3). It uses the geometric positions of these nodes to compute the angle."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The absolute value of the angle (in degrees) between the two edges formed by the three nodes."}),"\n",(0,r.jsx)(n.h2,{id:"getundirectededgesasnodeidsflatarray",children:"GetUndirectedEdgesAsNodeIdsFlatArray"}),"\n",(0,r.jsx)(n.p,{children:"Constructs a flat array representing undirected edges in a graph. Each pair of consecutive elements\r\nin the array represents an edge, where the first element of the pair is the ID of the first node, and\r\nthe second element is the ID of the second node of the edge."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["The array is structured so that for an edge at index i in the list of edges, the elements at\r\npositions 2",(0,r.jsx)(n.em,{children:"i and 2"}),"i + 1 in the flat array correspond to the IDs of the first and second nodes\r\nof that edge, respectively."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A flat array of integers where each successive pair of elements represents the node IDs of an edge."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:"\r\nvar flatEdges = graph.GetUndirectedEdgesAsNodeIdsFlatArray();\n// If the graph contains an edge between nodes 1 and 2, and another edge between nodes 3 and 4,\n// the flatEdges array might look like [1, 2, 3, 4], assuming these are the only edges in the graph.\n"})}),"\n",(0,r.jsx)(n.h2,{id:"joinforwardandbackwardweightsasflatarray",children:"JoinForwardAndBackwardWeightsAsFlatArray"}),"\n",(0,r.jsx)(n.p,{children:"Combines the forward and backward weight arrays of a specified weight matrix into a single, flat array."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix whose forward and backward weights are to be joined.\r\nThis ID should correspond to an existing weight matrix within the graph."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method is designed to work with both directed and undirected graphs. For directed graphs, it combines\r\nthe weights of edges in both forward and backward directions, creating a flat array that represents\r\nconcatenated the forward and backward weights. For undirected graphs, it simply returns\r\nthe forward weights."}),"\n",(0,r.jsx)(n.h2,{id:"getweightmatrixbyid",children:"GetWeightMatrixById"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves a weight matrix associated with a given identifier."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Id"})," - The identifier for the weight matrix to retrieve."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method assumes that a collection of weight matrices is indexed by identifiers, equal to the order of adding the matrices\r\nto the graph via ",(0,r.jsx)(n.a,{href:"#"})," function."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A 2-dimensional array of type  (float or double), representing the weight matrix for the graph\r\nassociated with the given ID."}),"\n",(0,r.jsx)(n.h2,{id:"isadjacent",children:"IsAdjacent"}),"\n",(0,r.jsx)(n.p,{children:"Determines whether two nodes in the graph are adjacent."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node1Id"})," - The identifier of the first node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node2Id"})," - The identifier of the second node."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method checks the adjacency matrix of the graph to determine if there is a direct edge between\r\ntwo nodes."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"true if there is a direct edge between the two nodes; otherwise, false."}),"\n",(0,r.jsx)(n.h2,{id:"isnodeidvalid",children:"IsNodeIdValid"}),"\n",(0,r.jsx)(n.p,{children:"Checks if a given node ID is valid within the current graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"NodeId"})," - The ID of the node to validate."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method verifies that the provided node ID is within the valid range of nodes in the graph,\r\nwhich is determined by the current count of nodes (",(0,r.jsx)(n.a,{href:"agraph#nodescount",children:"NodesCount"}),")."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"true if the node ID is less than the current count of nodes in the graph; otherwise, false."}),"\n",(0,r.jsx)(n.h2,{id:"getundirectededgeid",children:"GetUndirectedEdgeId"}),"\n",(0,r.jsx)(n.p,{children:"Returns an udirected edge ID."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"EdgeId"})," - The ID of the edge."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"EdgeId"})," is a directed edge ID, then a corresponding undirected edge ID is returned.\r\nIn case the ",(0,r.jsx)(n.code,{children:"EdgeId"})," corresponds to already undirected edge, it will be returned as it is."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The undirected edge ID."}),"\n",(0,r.jsx)(n.h2,{id:"getdirectedandundirectededgeidbynodes",children:"GetDirectedAndUndirectedEdgeIdByNodes"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the directed and undirected edge IDs for a pair of nodes."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node1Id"})," - The ID of the first node in the pair."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node2Id"})," - The ID of the second node in the pair."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method first retrieves the directed edge ID for the node pair specified by ",(0,r.jsx)(n.code,{children:"Node1Id"}),"\r\nand ",(0,r.jsx)(n.code,{children:"Node2Id"})," using the ",(0,r.jsx)(n.a,{href:"agraph#getdirectededgeidbynodes",children:"GetDirectedEdgeIdByNodes"})," method. It then obtains the\r\ncorresponding undirected edge ID by converting the directed edge ID via the ",(0,r.jsx)(n.a,{href:"agraph#getundirectededgeid",children:"GetUndirectedEdgeId"}),"\r\nmethod. In case nodes are not adjacent int.MaxValue will be returned."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A tuple containing the directed edge ID and the undirected edge ID for the specified node pair."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:"\r\n(int directedEdgeId, int undirectedEdgeId) = graph.GetDirectedAndUndirectedEdgeIdByNodes(node1Id, node2Id);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"getundirectededgeidbynodes",children:"GetUndirectedEdgeIdByNodes"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the undirected edge ID for an edge defined by two node IDs."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node1Id"})," - The ID of the first node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node2Id"})," - The ID of the second node."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method retrieves, first, the directed edge ID between the two specified nodes using\r\n",(0,r.jsx)(n.a,{href:"agraph#getdirectededgeidbynodes",children:"GetDirectedEdgeIdByNodes"})," and then converts it to an undirected edge ID using\r\n",(0,r.jsx)(n.a,{href:"agraph#getundirectededgeid",children:"GetUndirectedEdgeId"}),". In case nodes are not adjacent int.MaxValue will be returned."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The undirected edge ID corresponding to the edge between the specified nodes."}),"\n",(0,r.jsx)(n.h2,{id:"getdirectededgeidbynodes",children:"GetDirectedEdgeIdByNodes"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the directed edge ID for an edge defined by two node IDs."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node1Id"})," - The ID of the first node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node2Id"})," - The ID of the second node."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method retrieves the directed edge ID between the two specified nodes using\r\nIn case nodes are not adjacent int.MaxValue will be returned."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The undirected edge ID corresponding to the edge between the specified nodes."}),"\n",(0,r.jsx)(n.h2,{id:"getoppositeedgeid",children:"GetOppositeEdgeId"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the ID of the edge that is in the opposite direction to the given edge ID."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"EdgeId"})," - The ID of the edge for which the opposite direction edge ID is to be found."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method retrieves the edge Id that represents the same connection but in the opposite direction."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The ID of the edge that is in the opposite direction to the provided edge ID."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:"\r\nint oppositeDirectionEdgeId = graph.GetOppositeEdgeId(edgeId);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"getnodeidsbyedgeid",children:"GetNodeIdsByEdgeId"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the node IDs connected by a specified edge ID."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"EdgeId"})," - The identifier of the edge."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method returns the node IDs of a given edge ID for both directed and undirected edges."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A tuple containing the IDs of the two nodes connected by the edge. The order is (source, target) for directed edges."}),"\n",(0,r.jsx)(n.h2,{id:"getsubgraphs",children:"GetSubgraphs"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves all subgraphs within the graph as a list of lists, where each list contains the node IDs of a subgraph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method identifies and collects subgraphs by performing a depth-first search (DFS) starting from each unvisited node."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A list of subgraphs, each represented as a list of node IDs indicating the nodes that form the subgraph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cs",children:'\r\nList<List<int>> subgraphs = graph.GetSubgraphs();\nforeach (var subgraph in subgraphs)\n{\n    Console.WriteLine($"Subgraph: {string.Join(", ", subgraph)}");\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"apshortestpathsbyoneweight",children:"APShortestPathsByOneWeight"}),"\n",(0,r.jsx)(n.p,{children:"Calculates all-pairs shortest paths in the graph using the Floyd-Warshall algorithm, based on a specified weight matrix and a tolerance for distance comparison."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix to use for calculating distances with the Floyd-Warshall algorithm."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"GPU"})," - A boolean indicating if GPU acceleration should be utilized. Set to true for GPU computation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Tolerance"})," - The tolerance within which two distances are considered equal. The tolerance is of type  (double or float)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method employs the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes in the graph, considering a single weight for\r\neach edge as determined by the ",(0,r.jsx)(n.code,{children:"WeightMatrixId"}),". The ",(0,r.jsx)(n.code,{children:"Tolerance"})," parameter is used to treat distances as equal if they fall\r\nwithin this specified tolerance."]}),"\n",(0,r.jsxs)(n.p,{children:["The algorithm is executed on either the CPU or GPU, based on the ",(0,r.jsx)(n.code,{children:"GPU"})," parameter. When true, GPU acceleration is enabled."]}),"\n",(0,r.jsx)(n.h2,{id:"apshortestpathsbymanyweights",children:"APShortestPathsByManyWeights"}),"\n",(0,r.jsx)(n.p,{children:"Calculates all-pairs shortest paths in the graph using the Floyd-Warshall algorithm, based on 2 specified weight matrices and a tolerance for distance comparison."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix to use for calculating distances with the Floyd-Warshall algorithm."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"RelativeMatrixId"})," - Identifier for an alternative weight matrix to resolve cases when shortest paths by main weight matrix are equal within the tolerance."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"GPU"})," - A boolean indicating if GPU acceleration should be utilized. Set to true for GPU computation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Tolerance"})," - The tolerance within which two distances are considered equal. The tolerance is of type  (double or float)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method employs the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes in the graph, considering two weights for\r\neach edge as determined by the ",(0,r.jsx)(n.code,{children:"WeightMatrixId"})," and ",(0,r.jsx)(n.code,{children:"RelativeMatrixId"}),".\r\nIf the shortest path between a pair of nodes is equal within the margin defined by the ",(0,r.jsx)(n.code,{children:"Tolerance"})," parameter, the path with the\r\nsmaller distance, as determined by the ",(0,r.jsx)(n.code,{children:"RelativeMatrixId"}),", will be chosen as the solution."]}),"\n",(0,r.jsxs)(n.p,{children:["The algorithm is executed on either the CPU or GPU, based on the ",(0,r.jsx)(n.code,{children:"GPU"})," parameter. When true, GPU acceleration is enabled."]}),"\n",(0,r.jsx)(n.h2,{id:"initializenextmatrix",children:"InitializeNextMatrix"}),"\n",(0,r.jsx)(n.p,{children:"Initializes the 'Successor' matrix used for pathfinding, setting default values for direct paths and marking self-paths as invalid."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method sets up the 'Successor' matrix which is used for reconstructing paths after running pathfinding algorithms. Each cell\r\nin the matrix indicates the next node on the shortest path from origin node to destination node.\r\nSelf-paths, or paths from a node to itself, are marked as invalid with a default value of -1 ( ",(0,r.jsx)(n.a,{href:"agraph#novalue",children:"NoValue"}),"), indicating that such paths should not\r\nbe considered in path reconstruction."]}),"\n",(0,r.jsx)(n.h2,{id:"addemptyweightmatrix",children:"AddEmptyWeightMatrix"}),"\n",(0,r.jsx)(n.p,{children:"Adds new edges weights and a corresponding weight matrix to the graph, initializing all weights."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"DiagonalValue"})," - The weight value for paths from a node to itself within the matrix, indicating the self-path cost. By default double.MaxValue."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"IsDual"})," - Specifies whether the matrix is added for a dual graph or a primal graph. The default is false (primal graph)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method creates a new weight matrix where each edge's weight to itself is set to the given ",(0,r.jsx)(n.code,{children:"DiagonalValue"}),",\r\nby default double.MaxValue, indicating invalid travel from a node to itself. All other weights are initialized to represent infinite distance (double.MaxValue)."]}),"\n",(0,r.jsx)(n.p,{children:"Following initialization, the method creates a list of undirected edge weights (forward), setting all to represent infinite distance.\r\nFor directed graphs, a separate list for opposite direction edge weights (backward) is also created, applying the same infinite distance initialization.\r\nNote, that empty weight matrix can be added only if graph already have nodes and edges and weighted by at least one matrix."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The index of the newly added weight matrix, which can be used to reference it in future operations."}),"\n",(0,r.jsx)(n.h2,{id:"addweightmatrix",children:"AddWeightMatrix"}),"\n",(0,r.jsx)(n.p,{children:"Adds a new weight matrix to the graph and updates corresponding edge weights."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"WeightMatrix"})," - The weight matrix to be added, representing the weights between nodes in the graph."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method adds the specified weight matrix to the graph. For directed graphs, both directions of edge weights (forward and backward)\r\nare created based on the input weight matrix. For undirected graphs, only undirected edge weights (forward) are created."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The identifier of the newly added weight matrix."}),"\n",(0,r.jsx)(n.h2,{id:"removeweightmatrix",children:"RemoveWeightMatrix"}),"\n",(0,r.jsx)(n.p,{children:"Removes a specified weight matrix and its associated edge weights from the graph."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix to be removed."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"The method removes the weight matrix along with the associated undirected (forward) edge weights.\r\nFor directed graphs, edges in opposite direction (backward) weights corresponding to the same weight matrix ID are also removed."}),"\n",(0,r.jsx)(n.h2,{id:"setweightmatrixvalue",children:"SetWeightMatrixValue"}),"\n",(0,r.jsx)(n.p,{children:"Sets the weight value for an edge in a specified weight matrix."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Value"})," - The weight value to set for the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"FromNodeId"})," - The ID of the source node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"ToNodeId"})," - The ID of the destination node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix where the weight value is to be set."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method updates the weight of the edge from the origin node to the destination node in the specified weight matrix.\r\nNote that it updates only matrix without updating the edges lists. This is helpful for dual graphs only.\r\nIn other cases the ",(0,r.jsx)(n.a,{href:"agraph#setweightmatrixandedgevalue",children:"SetWeightMatrixAndEdgeValue"})," should be used."]}),"\n",(0,r.jsx)(n.h2,{id:"setweightmatrixandedgevalue",children:"SetWeightMatrixAndEdgeValue"}),"\n",(0,r.jsx)(n.p,{children:"Sets the weight for a specific edge in both the weight matrix and the corresponding edge list."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Value"})," - The weight value to set for the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"FromNodeId"})," - The ID of the source node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"ToNodeId"})," - The ID of the destination node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix where the weight value is to be set."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"Updates the specified edge's weight in the weight matrix and then adjusts the corresponding edge's value in the edge list.\r\nThis ensures consistency between the graph's internal representations of edge weights."}),"\n",(0,r.jsx)(n.h2,{id:"getedgevalue",children:"GetEdgeValue"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the weight value of an edge between two specified nodes by the given weight matrix ID."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"FromNodeId"})," - The ID of the source node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"ToNodeId"})," - The ID of the destination node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix where the weight value is to be set."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"The method retrieves the weight from the edge weights list, ensuring compatibility with both directed and undirected graph structures."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The weight value of the edge as specified in the edge list."}),"\n",(0,r.jsx)(n.h2,{id:"getedgevalue-1",children:"GetEdgeValue"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the weight value of an edge between two specified nodes by the given weight matrix ID."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"EdgeId"})," - The ID of the edge for which the weight is retrieved."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix where the weight value is to be set."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"The method retrieves the weight from the edge weights list, ensuring compatibility with both directed and undirected graph structures."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The weight value of the edge as specified in the edge list."}),"\n",(0,r.jsx)(n.h2,{id:"getweightmatrixvalue",children:"GetWeightMatrixValue"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the weight value of an edge between two specified nodes from the given weight matrix ID."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"FromNodeId"})," - The ID of the source node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"ToNodeId"})," - The ID of the destination node of the edge."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixId"})," - The identifier of the weight matrix where the weight value is to be set."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"The method retrieves the weight from the weight matrix."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"The weight value of the edge as specified in the weight matrix."}),"\n",(0,r.jsx)(n.h2,{id:"fillweightmatrixbysprestore",children:"FillWeightMatrixBySPRestore"}),"\n",(0,r.jsx)(n.p,{children:"Fills weight matrices with distances of shortest paths, reconstructed from the 'Successor' matrix, using specified weight matrix IDs."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"WeightMatrixIds"})," - An array of identifiers for the weight matrices to be updated with shortest path distances."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"GPU"})," - A boolean indicating if GPU acceleration should be utilized. Set to true for GPU computation."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsxs)(n.p,{children:["This method utilizes the 'Successor' matrix, which is calculated in previous steps, to retrace the shortest paths between all pairs of nodes\r\nand measure the existed paths according to other weights specified in parameter ",(0,r.jsx)(n.code,{children:"WeightMatrixIds"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Depending on the ",(0,r.jsx)(n.code,{children:"GPU"})," parameter, this process is performed either on the CPU or the GPU."]}),"\n",(0,r.jsx)(n.h2,{id:"convertdoubletofloatjaggedarray",children:"ConvertDoubleToFloatJaggedArray"}),"\n",(0,r.jsx)(n.p,{children:"Converts a jagged array of doubles to a jagged array of floats."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"DoubleArray"})," - The jagged array of doubles to convert."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Remarks"})}),"\n",(0,r.jsx)(n.p,{children:"This method converting each value in double array to float and populating a new jagged array of floats."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),"\n",(0,r.jsx)(n.p,{children:"A jagged array of floats corresponding to the input double array."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>d});t(6540);var r=t(4164);const s={tabItem:"tabItem_Ymn6"};var i=t(4848);function d(e){let{children:n,hidden:t,className:d}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,d),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>I});var r=t(6540),s=t(4164),i=t(3104),d=t(6347),h=t(205),a=t(7485),o=t(1682),l=t(9466);function c(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function g(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return c(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,o.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function x(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const s=(0,d.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,a.aZ)(i),(0,r.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(s.location.search);n.set(i,e),s.replace({...s.location,search:n.toString()})}),[i,s])]}function u(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,i=g(e),[d,a]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!x({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[o,c]=p({queryString:t,groupId:s}),[u,j]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,i]=(0,l.Dv)(t);return[s,(0,r.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:s}),m=(()=>{const e=o??u;return x({value:e,tabValues:i})?e:null})();(0,h.A)((()=>{m&&a(m)}),[m]);return{selectedValue:d,selectValue:(0,r.useCallback)((e=>{if(!x({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);a(e),c(e),j(e)}),[c,j,i]),tabValues:i}}var j=t(2303);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(4848);function w(e){let{className:n,block:t,selectedValue:r,selectValue:d,tabValues:h}=e;const a=[],{blockElementScrollPositionUntilNextRender:o}=(0,i.a_)(),l=e=>{const n=e.currentTarget,t=a.indexOf(n),s=h[t].value;s!==r&&(o(n),d(s))},c=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;n=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;n=a[t]??a[a.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:h.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>a.push(e),onKeyDown:c,onClick:l,...i,className:(0,s.A)("tabs__item",m.tabItem,i?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function b(e){let{lazy:n,children:t,selectedValue:s}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function v(e){const n=u(e);return(0,f.jsxs)("div",{className:(0,s.A)("tabs-container",m.tabList),children:[(0,f.jsx)(w,{...e,...n}),(0,f.jsx)(b,{...e,...n})]})}function I(e){const n=(0,j.A)();return(0,f.jsx)(v,{...e,children:c(e.children)},String(n))}}}]);